## Title: Exploit Development Tutorial for Hackers and Pentesters
- Instructor: Swapnil Singh

## Section 1: Introduction

1. Thanks for joining

2. What skills are needed for this course?

3. Lab machine configurations
- Ubuntu 18.04.1

## Section 2: Binary Analysis Fundamentals for Exploit Development

4. Before any Exploitations
- Get the target information using tools

5. Installing gdb plugins for exploit development lab
- github.com/longld/peda
```
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
echo "DONE! debug your program with gdb and enjoy"
```

6. GDB basics for exploit development
- For disassemble only, we may not need -g option to build an executable
- Compile the code with -no-pie option
- hello.c:
```c
#include<stdio.h>
int myF() { int i=10; char *myS = "This is my F"; return 0; }
int main() { int a = 100; char *mainS = "This is main function";
             myF(); return 0; }
```
- Demo:
```bash
$ gcc -no-pie hello.c -o hello.exe
$ gdb -q hello.exe
Reading symbols from hello.exe...
(No debugging symbols found in hello.exe)
gdb-peda$ disassemble main
Dump of assembler code for function main:
   0x0000000000401127 <+0>:	endbr64 
   0x000000000040112b <+4>:	push   rbp
   0x000000000040112c <+5>:	mov    rbp,rsp
   0x000000000040112f <+8>:	sub    rsp,0x10
   0x0000000000401133 <+12>:	mov    DWORD PTR [rbp-0xc],0x64
   0x000000000040113a <+19>:	lea    rax,[rip+0xed0]        # 0x402011
   0x0000000000401141 <+26>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401145 <+30>:	mov    eax,0x0
   0x000000000040114a <+35>:	call   0x401106 <myF>
   0x000000000040114f <+40>:	mov    eax,0x0
   0x0000000000401154 <+45>:	leave  
   0x0000000000401155 <+46>:	ret    
End of assembler dump.
gdb-peda$ b *0x000000000040112f
Breakpoint 1 at 0x40112f
gdb-peda$ run
Starting program: /home/hpjeon/hw/class/udemy_exploit/chap05/hello.exe 
[----------------------------------registers-----------------------------------]
RAX: 0x401127 (<main>:	endbr64)
RBX: 0x401160 (<__libc_csu_init>:	endbr64)
RCX: 0x401160 (<__libc_csu_init>:	endbr64)
RDX: 0x7fffffffd668 --> 0x7fffffffda24 ("SHELL=/bin/bash")
RSI: 0x7fffffffd658 --> 0x7fffffffd9ef ("/home/hpjeon/hw/class/udemy_exploit/chap05/hello.exe")
RDI: 0x1 
RBP: 0x7fffffffd560 --> 0x0 
RSP: 0x7fffffffd560 --> 0x0 
RIP: 0x40112f (<main+8>:	sub    rsp,0x10)
R8 : 0x0 
R9 : 0x7ffff7fe0d60 (<_dl_fini>:	endbr64)
R10: 0x3 
R11: 0x2 
R12: 0x401020 (<_start>:	endbr64)
R13: 0x7fffffffd650 --> 0x1 
R14: 0x0 
R15: 0x0
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x401127 <main>:	endbr64 
   0x40112b <main+4>:	push   rbp
   0x40112c <main+5>:	mov    rbp,rsp
=> 0x40112f <main+8>:	sub    rsp,0x10
   0x401133 <main+12>:	mov    DWORD PTR [rbp-0xc],0x64
   0x40113a <main+19>:	lea    rax,[rip+0xed0]        # 0x402011
   0x401141 <main+26>:	mov    QWORD PTR [rbp-0x8],rax
   0x401145 <main+30>:	mov    eax,0x0
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffd560 --> 0x0 
0008| 0x7fffffffd568 --> 0x7ffff7dd3083 (<__libc_start_main+243>:	mov    edi,eax)
0016| 0x7fffffffd570 --> 0x7ffff7ffc620 --> 0x504fc00000000 
0024| 0x7fffffffd578 --> 0x7fffffffd658 --> 0x7fffffffd9ef ("/home/hpjeon/hw/class/udemy_exploit/chap05/hello.exe")
0032| 0x7fffffffd580 --> 0x100000000 
0040| 0x7fffffffd588 --> 0x401127 (<main>:	endbr64)
0048| 0x7fffffffd590 --> 0x401160 (<__libc_csu_init>:	endbr64)
0056| 0x7fffffffd598 --> 0xf728f019017155c0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Breakpoint 1, 0x000000000040112f in main ()
gdb-peda$ x/d $rbp
0x7fffffffd560:	0
gdb-peda$ x/d $rbp-0xc  # prints decimal
0x7fffffffd554:	100
gdb-peda$ x/s $ras
gdb-peda$ ni
gdb-peda$ ni
gdb-peda$ ni
gdb-peda$ x/s $rax  # prints as a string
0x402011:	"This is main function"
```
- `ni` for next instruction
- `c` for continue

7. Binary compilation process
- gcc -S sample.c: produces an assembly code sample.s
- gcc -c sample.s: produces an object file sample.o
- gcc sample.o -o sample.exe: produces an executable sample.exe

8. Staic memory layout of Binary file
- .data: global data
- .bss: uninitialized data
- .rodata: read-only data like strings
- .text: contains the executable code, machine instruction, ...
- other data
- sample.c:
```c
#include <stdio.h>
int a = 100;
char *str = "I am Global";
int b;
int main() {
  int b = 20;
  char *mystr = "I am main";
  printf("hello world\n");
  return 0;
}
```
- Analyzing sections:
```bash
$ readelf -x .rodata ./a.out
Hex dump of section '.rodata':
  0x00002000 01000200 4920616d 20476c6f 62616c00 ....I am Global.
  0x00002010 4920616d 206d6169 6e006865 6c6c6f20 I am main.hello 
  0x00002020 776f726c 6400                       world.
$ readelf -x .bss ./a.out # .bss will contain data when run
Section '.bss' has no data to dump.
$ readelf -x .data ./a.out
Hex dump of section '.data':
  0x00004000 00000000 00000000 08400000 00000000 .........@......
  0x00004010 64000000 00000000 04200000 00000000 d........ ......
```

9. Dynamic memory layout inside the process
- When a program is executed, it fills memory with such as:
  - .text
  - .bss
  - .rodata
  - .data
  - Heap
  - Unused memory
  - Stack

10. What is the purpose of stack in memory?

11. Memory segmentation of binary and stack

12. Concept of stack inside the binary

13. Full examination of stack area in binary

14. Full analysis of stacks in multi level functions of binary
